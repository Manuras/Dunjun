# Dunjun #
This project will be documenting and demonstrating the development of making a game from scratch<sup>1</sup>! Every step of the game development process and every line of code will be explained thoroughly.

The game will be a 3D randomly generated, perma-death, dungeon crawler style game. More will be revealed about the game as the project persists.

YouTube Channel: [GingerGames](https://youtube.com/c/GingerGames)

GitHub: [Dunjun GitHub](https://github.com/gingerBill/Dunjun)

<sup>1</sup>*With minimal libraries such as GLFW, GLEW, and the STB libraries.*

## YouTube Playlists ##

* [Dunjun Playlist](https://www.youtube.com/playlist?list=PL93bFkoCMJslJJb15oQddnmABNUl6iz8e)
* [Bare Bones](https://www.youtube.com/playlist?list=PL93bFkoCMJsnFFCfFZ8iwzwnobALHoarE)
* [Vectors and Matrices](https://www.youtube.com/playlist?list=PL93bFkoCMJskms6yv5FXx61C7Tai7amrT)
* [Model Assets and Model Instances](https://www.youtube.com/playlist?list=PL93bFkoCMJsksaZto9IK1jbjhWw0glUDs)
* [Quaternions and Rotations in 3D](https://www.youtube.com/playlist?list=PL93bFkoCMJsmLfAhNyeXzhH-POMvBAn6y)
* [Camera and Input](https://www.youtube.com/playlist?list=PL93bFkoCMJslgYPipJ-6k7jwRxlO6fyha)
* [Mesh Creation](https://www.youtube.com/playlist?list=PL93bFkoCMJskXMQcGKayIfx50sIAepgz8)
* [Model Generation](https://www.youtube.com/playlist?list=PL93bFkoCMJskkGve-UUx9l7_adMAI9Vni)
* [Scene Graphs and Component Based Design](https://www.youtube.com/playlist?list=PL93bFkoCMJslkX7gQb56j4phER1FmTRCV)
* Lighting and Deferred Rendering

## Episode List ##

### Introduction ###

* [000 - Introduction](https://www.youtube.com/watch?v=fRUYl6_5m3o&index=1&list=PL93bFkoCMJslJJb15oQddnmABNUl6iz8e)

### [Bare Bones](https://www.youtube.com/playlist?list=PL93bFkoCMJsnFFCfFZ8iwzwnobALHoarE) ###

* [001 - Project Setup (Visual Studio)](https://www.youtube.com/watch?v=Vzve8VOn8qA&index=2&list=PL93bFkoCMJslJJb15oQddnmABNUl6iz8e)
* [002 - Creating a Window (GLFW3)](https://www.youtube.com/watch?v=LNxpDcRs8Zg&list=PL93bFkoCMJslJJb15oQddnmABNUl6iz8e&index=3)
* [003 - Drawing with OpenGL (GLEW)](https://www.youtube.com/watch?v=42x_p1PeecU)
* [004 - Shader Program Class](https://www.youtube.com/watch?v=fLSLJ66AEOU)
* [005 - Textures (STB)](https://www.youtube.com/watch?v=eiz7ZZBtUA0)
* [006 - Image Loader](https://www.youtube.com/watch?v=Wl0jh_CBT8w)
* [007 - Texture Wrapper](https://www.youtube.com/watch?v=2i2jX4yb8sI)
* [008 - Error Handling & Code Tidying](https://www.youtube.com/watch?v=jUUGEFV7rk0)

### [Vectors and Matrices](https://www.youtube.com/playlist?list=PL93bFkoCMJskms6yv5FXx61C7Tai7amrT) ###

* [009 - Introduction to Transformations with Matrices](https://www.youtube.com/watch?v=imjaU0gO1vY)
* [010 - Implement Basic Vector Types](https://www.youtube.com/watch?v=MSHeE7kAqbA)
* [011 - Vector Functions](https://www.youtube.com/watch?v=sX_1BSVp-ok)
* [012 - Matrix4 Type](https://www.youtube.com/watch?v=fcHEk02Hasg)
* [013 - Matrix Transform Functions](https://www.youtube.com/watch?v=WEpA4NbN-xQ)
* [014 - View & Projection Matrices & Angles](https://www.youtube.com/watch?v=QAIbGN_oXdo)
* [015 - Constants, Code Tidying & GLSL Convention](https://www.youtube.com/watch?v=hQw7_DWjQtg)

### [Model Assets and Model Instances](https://www.youtube.com/playlist?list=PL93bFkoCMJsksaZto9IK1jbjhWw0glUDs) ###

* [016 - ModelAssets & ModelInstances](https://www.youtube.com/watch?v=oDwALlxMa4k)

### [Quaternions and Rotations in 3D](https://www.youtube.com/playlist?list=PL93bFkoCMJsmLfAhNyeXzhH-POMvBAn6y) ###

* [017 - Introduction to Complex Numbers](https://www.youtube.com/watch?v=NpkoqTOWn4E)
* [018 - Introduction to Quaternions](https://www.youtube.com/watch?v=Vhtw7EvLuQQ)
* [019 - Quaternion Interpolation](https://www.youtube.com/watch?v=GFnWLM_HcKw)
* [020 - Implement Quaternions](https://www.youtube.com/watch?v=7rZWS_62rXY)
* [021 - Quaternion Functions](https://www.youtube.com/watch?v=8pUqEspcS8w)
* [022 - Transform Type](https://www.youtube.com/watch?v=XVkJkczl6tM)

### [Camera and Input](https://www.youtube.com/playlist?list=PL93bFkoCMJslgYPipJ-6k7jwRxlO6fyha) ###

* [023 - Fixed Time Step & Code Tidying](https://www.youtube.com/watch?v=t5mZi9bJX3A)
* [024 - ReadOnly Types & Camera Type](https://www.youtube.com/watch?v=l-DFRShm5wE)
* [025 - Complete Camera & Depth Testing](https://www.youtube.com/watch?v=30QORMjrpKA)
* [026 - Basic First Person Camera Input](https://www.youtube.com/watch?v=dkYK0e0m_H0)
* [027 - Game Separation and Input Wrapper](https://www.youtube.com/watch?v=9bpZjQYPXqg)
* [028 - XInput Gamepads](https://www.youtube.com/watch?v=NAVaHMDNPjQ)
* [029 - Gamepad Camera Control](https://www.youtube.com/watch?v=JHNUHLgqBo4)
* [030 - Mouse Buttons and Scroll Input](https://www.youtube.com/watch?v=oJmDEtCX9a0)
* [030.5 - Input Enums & Camera Transform Fix](https://www.youtube.com/watch?v=rrMtsh2GZ0Y)

### [Mesh Creation](https://www.youtube.com/playlist?list=PL93bFkoCMJskXMQcGKayIfx50sIAepgz8) ###

* [031 - Plans for Game](https://www.youtube.com/watch?v=s0-Ru3rIPeU)
* [032 - Basic Level and Billboards](https://www.youtube.com/watch?v=OtvRnrakTkU)
* [033 - Finish Billboards and Start Mesh](https://www.youtube.com/watch?v=6MNVfDS59m0)
* [034 - Materials and Meshes](https://www.youtube.com/watch?v=Fkl4qeuHT2A)

### [Model Generation](https://www.youtube.com/playlist?list=PL93bFkoCMJskkGve-UUx9l7_adMAI9Vni) ###

* [035 - Textured Tiled Room](https://www.youtube.com/watch?v=TMr1hDw6BoE)
* [036 - Add Tile Surfaces and Random Tile Sets](https://www.youtube.com/watch?v=DhDtvNRFLkA)
* [037 - Level Class and Code Tidying](https://www.youtube.com/watch?v=d2AnU8MoMGM)
* [038 - Fullscreen Support and Window Functions](https://www.youtube.com/watch?v=KuwnMEOtkxc)
* [039 - Level Generation](https://www.youtube.com/watch?v=42cc43q1hcs)
* [040 - Random Numbers and Experimental Camera](https://www.youtube.com/watch?v=zlrwvH8WGms)
* [041 - Camera Swapping & Mesh::Data Helpers](https://www.youtube.com/watch?v=y0AlRG9x4Ow)
* [042 - Random Non-Connected Rooms](https://www.youtube.com/watch?v=9IGk-eyoTs0)
* [043 - Non-Overlapping Rooms](https://www.youtube.com/watch?v=qUskLwsedAo)
* [044 - Code Review](https://www.youtube.com/watch?v=ChGR0LVsF2g)

### [Scene Graphs and Component Based Design](https://www.youtube.com/playlist?list=PL93bFkoCMJslkX7gQb56j4phER1FmTRCV) ###

* [045 - Scene Graphs and SceneNodes](https://www.youtube.com/watch?v=nC34SQ3X_JY)
* [046 - Component Based Design and NodeComponent](https://www.youtube.com/watch?v=uvu4Z2ntyO8)
* [047 - Renderer and FaceCamera Component](https://www.youtube.com/watch?v=WLwd84Fu3TU)
* [048 - Passing SceneNodes to the Renderer](https://www.youtube.com/watch?v=vPviA28caBU)
* [049 - Room SceneNodes](https://www.youtube.com/watch?v=uiIbkzPmvlg)
* [050 - Drawables and Level SceneNode](https://www.youtube.com/watch?v=4ujU1ioQJDk)
* [051 - Random Walk Level Generation](https://www.youtube.com/watch?v=WWi_PKwyCd0&)
* [052 - SceneNode Optimization & Many Room Levels](https://www.youtube.com/watch?v=eIyGimZZwmQ)
* [053](https://www.youtube.com/watch?v=2GzueWyIW4M)
	- [a - Math Library](https://www.youtube.com/watch?v=2GzueWyIW4)
	- [b - Doorways for Adjacent Rooms](https://www.youtube.com/watch?v=2GzueWyIW4M&t=736)
* [054 - Distance Culling and Cone Culling](https://www.youtube.com/watch?v=CNWzlDofqJc)
* [055 - Batch Rendering - Sorting by Material](https://www.youtube.com/watch?v=2xJXXbacL_8)

### Lighting and Deferred Rendering ###

* [056 - Diffuse Point Lighting](https://www.youtube.com/watch?v=vdRyBV4E4QY)
* [057 - Point Light Implementation](https://www.youtube.com/watch?v=47lrKz_hAsE)
* [058 - Ambience, Specularity, and Attenuation](https://www.youtube.com/watch?v=eNBq3hTi104)
* [059 - Limit Light Range and Material Structure](https://www.youtube.com/watch?v=P2qFvrkdulU)
* [060 - GLSL Material and Light Range Calculation](https://www.youtube.com/watch?v=McKbxvSYuLg)
* [061 - RenderTexture](https://www.youtube.com/watch?v=AjPYDwmSMeY)
* 062 - Deferred Shading & GBuffer
* 063 - Deferred Geometry Pass
* 064 - Deferred Point Lighting

## Contact ##

* YouTube: [GingerGames](https://youtube.com/c/GingerGames)
* Email: dunjun@gingerBill.org
* GitHub: [Dunjun GitHub](https://github.com/gingerBill/Dunjun)

## FAQ ##

### Will this be a simple game, for teaching purposes? ###

No! In fact, the game design has been made to require *complex concepts* which exist in more than most game designs.

### Are the accompanying videos just recordings of someone programming? ###

No! 99%<sup>1</sup> of the programming for the game is recorded in the videos; every step of the game development process and every line of code will be explained thoroughly.

<sup>1</sup>*Some of the code will not programmed in the videos but this will mostly be bug fixes or minor changes to the code that can be explained quickly.*

### What platforms will this game support? ###

This game will support Windows<sup>1</sup>, Mac OS X<sup>2</sup>, and Linux<sup>3</sup><sup>4</sup>.

<sup>1</sup>*XP and Above*
<sup>2</sup>*OS X 10.8+.*
<sup>3</sup>*Including Steam OS.*
<sup>4</sup>*Most likely Debian based systems only.*

### I have a problem with X... ###

Please feel free to contact with any problem:

* YouTube: [GingerGames](https://youtube.com/c/GingerGames)
* Email: dunjun@gingerBill.org
* GitHub: [Dunjun GitHub](https://github.com/gingerBill/Dunjun)

## Prerequisites ##

Before we can begin, you need to make sure you have all the things you will need.

* A reasonable amount of experience with C++
	- C++11 experience will help
* Graphics card compatible with OpenGL 2.1
	- DirectX 9 Equivalent Cards
* Text Editor and C++11 Compiler, or IDE (MSVC 12 compiler capabilities at least)
* The initial libraries:
	- GLFW - For creating the context, window, and handling input
	- GLEW - To use new OpenGL functions

## Building ##

At the moment, only Windows is supported through the Visual Studio solution. Mac OS X and Linux will implemented later when needed/wanted.

Most of the code should compile on Mac OS X and Linux with probably only a few minor changes<sup>1</sup>.

<sup>1</sup>_XInput is required (at the moment) for gamepad control however, GLFW does support joystick so that could be used a workaround for the moment._

## Supported Platforms ##

Graphics APIs:

* *OpenGL* 2.1 (through GLEW)

Platforms:

* *Windows* (Through MSVC 12)
* *OS X* (To be added)
* *Linux* (To be added)

## Dependencies ##

### Tools ###

* C++ compiler with decent C++11 support
	- If Visual Studio, please use *at least* MSVC 12.
	- Clang is preferred to GCC on other platforms but not necessary.

### Libraries ###

* OpenGL (Rendering)
* GLFW 3.1 (Window, Input and, Context Handling)
* GLEW (OpenGL Extension Wrangler Library)
* STB Libraries (Image and Font Loading)

## Conventions ##

* See clang-format-style.yaml for formatting style
* Allman Indenting
* CamelCase
* Tabs for indentation
* Spaces for alignment
* More below!

### Classes ###

PascalCase (Upper CamelCase) (e.g. ShaderProgram)

### Functions, Methods, and Variables ###

camelCase (e.g. loadFromFile)

### Namespaces ###

PascalCase (e.g. Dunjun::)

The end of a namespace must appended by `namespace` then its name.

Example:

```c++
namespace Dunjun
{
namespace Inner
{
...
} // namespace Inner
} // namespace Dunjun
```

### Using and Typedef ###

In C++11, `using` is a superset of `typedef`. `using` is preferred in this style guide.

```c++
// Using
using FooBar = std::pair<Foo, Bar>;
// Typedef
typedef std::pair<Foo, Bar> FooBar;
```

### Comments ###

C++ style comments `//` are preferred but C-style comments `/**/` can be used. The reasoning is that C-style comments cannot be nested and most IDEs/Editors can comments whole blocks in the C++ style which can allow for uncommenting a single line easily.

### Arrays and Vectors ###

When an collection of data is needed, use a `std::vector` unless it is fixed at runtime. If it is fixed at runtime use a classic C array or `std::array`. `std::array` is preferred as it is more C++ but they are exactly the same as it is just a class version of the classic C array.

The vector's elements are guaranteed to be contiguous, so you can pass `&v[0]` to any function expecting a pointer to an array; e.g., C library routines, OpenGL. Also, `std::vector<char> buffer(2048);` is a brilliant way to allocate a local buffer.

Use `std::vector` **unless** the profiler says that there is a problem **and** the array is tiny.

### Pointers ###

Raw pointers (e.g. Bar*) can be used, but if a smart pointer can be used, please do so.

Shorthand for smart pointers (`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`) of classes can be declared with using.

* UPtr -> unique_ptr
* SPtr -> shared_ptr
* WPtr -> weak_ptr

Do not use `std::auto_ptr`, use `std::unique_ptr` as it is much better and `std::auto_ptr` is depreciated.
`std::shared_ptr`s and `std::weak_ptr`s are to be use sparingly.

Example:

```c++
class Bar
{
public:
	using UPtr = std::unique_ptr<Bar>;
	using SPtr = std::shared_ptr<Bar>;
	using WPtr = std::weak_ptr<Bar>;

	...
};
```

If a class/etc. does not need a certain smart pointer, do not give a shorthand.

### Variables ###

camelCase (e.g. temp, m\_world, s\_time)

### Variable Prefixes ###

* m_ for protected/private member variables
* s_ for static/local persist variables
* g_ for global variables (*should* never be used! (except on a few rare occasions but if done so, place them within a namespace, at least!))


Example:

```c++
GLOBAL f32 g_globalVar;
extern int g_externVar;

class Foo
{
	void func()
	{
		LOCAL\_PERSIST u64 s_localVar;

		...
	}

private:
	char m_memberVar;
};
```

### Enums ###

All enum items should use PascalCase (e.g. `CursorMode`).

If a strong enum is preferred, please use one (e.g. `enum class`).

Example:

```c++
enum class CursorMode
{
	Normal,
	Hidden,
	Disabled,
};
```

If a weak enum is needed, please prefix the item with the name of the enum then an underscore.

Example (made up):

```c++
enum Flag : u32
{
	Flag_1 = (1 << 0),
	Flag_2 = (1 << 1),
	Flag_3 = (1 << 2),
	Flag_4 = (1 << 3),
	Flag_5 = (1 << 4),
	Flag_6 = (1 << 5),
	Flag_7 = (1 << 6),
	Flag_8 = (1 << 7),

	Flag_A = Flag_1,
	Flag_B = Flag_2,
	Flag_C = Flag_3,
};
```

### Static Defines ###

In `Dunjun/Common.hpp`, there are some defines for static:

```c++
#define GLOBAL static
#define INTERNAL static
#define LOCAL_PERSIST static
```

Please using these rather than the keyword static to indicate which type of static is being used.

Example:

```c++
GLOBAL int g_thingy;

INTERNAL void doSomething()
{
	LOCAL\_PERSIST char s\_buffer[10];

	...
}
```

### Annotations ###

* TODO      - todo
* NOTE      - note to reader (can be used in conjunction with TODO)
* IMPORTANT - important (can be used in conjunction with TODO or NOTE)
* FIXME     - fix as soon as possible (does not work as intended/not at all)
* HACK      - don't use in production (similar to FIXME but still works)

Example:

```c++
// TODO(fred) IMPORTANT(fred): This is some example text for a todo that is
//     important. It also spans multiple lines. This annotation was written
//     by `fred` as indicated next to the annotation.

```
